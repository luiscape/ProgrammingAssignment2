# Coursera R Programming Course: Programming Assignment 3 
# ========================================================
#
# This programming assigment tests the ability to use R scoping rules
# to create cache systems. It also tests the ability to document code 
# and share it publicly using GitHub. 
# 
# PS: I've created a performance test [source(test.R)] for the functions
#     below. The results are impressive: https://github.com/luiscape/ProgrammingAssignment2/blob/master/performance.png
# 
# Description:
# ------------
# 
# This script contains two functions: 
# 
#     > makeCacheMatrix: creates a 'matrix' object that can create a random matrix
#           and allows the calculation of the inverse of that matrix.
#             params: x = a numeric vector.
# 
#     > cacheSolve: calculates the operations in makeCacheMatrix 
#           looking for a cache. If makeCacheMatrix had been already 
#           run with the same parameters, the cached result will be fetched
#           avoiding another calculation. 
#             params: a makeCacheMatrix object with a valid numeric parameter.
# 
# Author
# ------
# 
# Luis Capelo | @luiscape 



# makeCacheMatrix is a collection of functions for making a matrix, 
# calculating its inverse, and storing its result in a cache vector (`m`). 
# The function takes a numeric vector as input.
makeCacheMatrix <- function(x = numeric()) {
  
  # The `replicate` function below replicates `x` times 
  # the random numbers generated by the `runif` function. 
  # Since the `x` parameter is the same for `runif` and `replicate`
  # the result is a square matrix.
  x <- replicate(x, floor(runif(x, 1,50)))
  
  # The `m` vector is where the "memory" will be cached.
  m <- NULL
  
  # The set function is used to store values in hte `m` vector.
  set <- function(y) {
    
    # Defining `x` in the makeCacheMatrix environment.
    x <<- y
    
    # Defining `m` in the makeCacheMatrix environment.
    m <<- NULL
  }
  
  # Function to trigger the creation of the matrix.
  get <- function() x
  
  # Function to store the inverse in the `m` ("memory") variable.
  # When run inside cacheSolve it stores `m` in cacheSolve's environment.
  setinverse <- function(solve) m <<- solve
  
  # Function to retrieve what has been stored in `m`. 
  getinverse <- function() m
  
  # Creating a list of functions to be called by cacheSolve.
  list(set = set, get = get,
       setinverse = setinverse,
       getinverse = getinverse)
  
}


# The cacheSolve function will execute the functions in makeCacheMatrix. 
# It tries to retrieve what has been stored in the `m` variable (what has been
# cached) before calculating the inverse of a matrix. 
# cacheSolve takes a makeCacheMatrix object.
cacheSolve <- function(x, ...) {
  
  # Here we trigger the `getinverse` function from makeCacheMatrix.
  # It will give back the inverse of a matrix stored in `m` or NULL
  # if that inverse hasn't been calculated yet.
  m <- x$getinverse()
  
  # If the inverse of a matrix has been stored in `m` within the 
  # makeCacheMatrix environment this control structure 
  # will simply return `m` avoiding another calculation.
  if(!is.null(m)) {
    message("Fetching cached data . . .")
    return(m)
  }  

  # If `m` is NULL (empty), we provide the matrix and make the calculation.
  data <- x$get()
  m <- solve(data, ...)
  
  # We also store the results of the calculation back to the `m` in the 
  # makeCacheMatrix environment so that if cacheSolve is run again
  # it can only retrieve the `m` cache without having to do another calculation.
  x$setinverse(m)
  m
  
}